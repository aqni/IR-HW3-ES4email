# HW3 邮件检索系统实现

> 匿名

## 索引构建

### mappings定义

在es中建立映射，类型如下。

```python
    mappings = {
        "properties": {
            "Message-ID": {"type": "keyword"},
            "date": {
                "type": "date",
                "format": "strict_date_optional_time", #使用ISO标准格式
            },
            "from": { #将发件人地址和名称分开保存
                "type": "object",
                "properties": {
                    "name": {
                        "type": "keyword",
                    },
                    "address": {
                        "type": "keyword",
                    },
                }
            },
            "to": { 
                "type": "object",
                "properties": {
                    "name": {
                        "type": "keyword",
                    },
                    "address": {
                        "type": "keyword",
                    },
                }
            },
            "flie": {"type": "keyword", }, #以数组方式保存所有包含的附加名称
            "subject": {"type": "text", },
            "length": {"type": "integer", }, #用整数保存正文长度
            "body": {
                "type": "text",
                "analyzer": "english" #使用英文分析器
            },
        }
    }
```

## 数据集文本解析

### 邮件头部信息

解析邮件头部信息，使用python官方库`email`来处理,可以以键值对的形式获得头部信息，如`From`、`subject`等。

```python
from email.parser import Parser
e = Parser().parse(f)
```

### 附件的解析

经过观察，数据集中的附加在文本中的形式总是以“ - ”开头，同时带有文件后缀，因此用正则表达式查找。

```python
filePattern = re.compile("\ -\ [\w\-\ ]*(\.[\w\-]+)+")
[x.group()[3:] for x in MailIndex.filePattern.finditer(body)]
```

### 收件人分词

收件人可能有多个，但是我希望保存为数组类型，因此需要对收件人进行手动分词。

```python
[x.strip() for x in (email["To"].split(', ') if email["To"] else [])]
#这里的if判断，是为了便于在插入时，不再进行None判断
```

### 编码问题

安然数据集读取字符的过程中可能`0xa0`相关的错误，需要用`'windows-1252'`编码打开。

## Doc插入

### 插入action构造

```python
    def mailAddAction(email: message) -> dict:
        body = email.get_payload()
        return {
            "Message-ID": email["Message-ID"].strip('<|>'),
            "date": dateutil.parser.parse(email["Date"]).isoformat(),
            "from.name": email["X-From"],
            "from.address": email["From"],
            "to.name": [x[0:x.find('<')].strip() for x in (email["X-To"].split(', ') if email["X-To"] else [])],
            "to.address": [x.strip() for x in (email["To"].split(', ') if email["To"] else [])],
            "flie": [x.group()[3:] for x in MailIndex.filePattern.finditer(body)],
            "subject": email["Subject"],
            "length": len(body),
            "body": body,
        }

    #在解析的循环中，加入到批次中进行处理
    batch.append(action)
```

### 批量插入

为了提高向ES插入数据下性能，使用bulk进行批量插入

```python
helpers.bulk(self.client,batch,index=self.indexName)
```

## 检索功能

检索功能通过一个简单的GUI体现。该GUI程序总体上是一个bool检索，对各个查询属性进行综合查找。此外，这里没有使用bool过滤器，是因为bool检索可以给出分数，而过滤器不能。

### 对keyword类型的检索

包括对`ID`,`From`,`File`等属性的检索。

这里采取灵活的搜索方式，包括`["match", "term", "fuzzy", "wildcard", "regexp", "prefix"]`这些可选的搜索方式。

query的基本结构如下

```python
    def getQuery(self):
        query = {
            self.match.getMatch(): { #getMatch()获得GUI选择的查询方式，如fuzzy
                self.name: self.entry.get() #查询的域和输入的query
            }
        } if self.entry.get() else None #None保护
        return self.should.getShould(), query #getShould()获得在在整个项bool查询方式，如should
```

搜索方式的选择：

<img src="%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20211121213201950.png" alt="image-20211121213201950" style="zoom:50%;" />

### 对text类型的检索

包括对主题和正文的检索。

由于ES会对text进行分词，而且这些项通常比较长，用“match”查询应该就够了。

query的基本结构

```pyton
    def getQuery(self):
        query = {
            "match": {
                self.name: self.entry.get()
            }
        } if self.entry.get() else None
        return self.should.getShould(), query
```



### 对范围的检索

包括对正文长度、日期的检索。

这里使用“range”查询，查询用户输入的范围。

```python
 {"range": {self.name: {
     "gte":#用户输入，
     "lte":#用户输入,
 }}}
```



### 各项综合

综合用户输入的各项进行一个Bool查询。

```python
    def getQuery(self) -> dict:
        result = {
            "bool": {
                "must": [],
                "must_not": [],
                "should": []
            }
        }
        for form in self.allForm:
            should, q = form.getQuery()#should为[None, "should", "must", "must_not"]之一
            if q and should:           #q为子项的查询
                result["bool"][should].append(q) 

        return result
```

各子项的bool检索要求("should", "must", "must_not")的选择，如图：

<img src="%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20211121213318392.png" alt="image-20211121213318392" style="zoom: 50%;" />

## 检索示例

<img src="%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20211121213940697.png" alt="image-20211121213940697" style="zoom:50%;" />

对.dat类型附件进行搜索，对时间和正文长度进行了强制要求，结果展示最多展示十条（tkinter的GUI功能比较简陋，多了不好显示）。

<img src="%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20211121213929011.png" alt="image-20211121213929011" style="zoom:50%;" />

点击项可查看正文，

<img src="%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20211121213647770.png" alt="image-20211121213647770" style="zoom:50%;" />

## 体会

### ES插入性能

对整个数据集进行构建，花了将近40分钟。性能的主要问题还是出在python和ES间的网络通信上。这里我采用的是批量插入，当batch在500以上时，速度能达到每秒2000文件，但是batch小的时候，速度仅有每秒200文件。

![image-20211121211625164](%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20211121211625164.png)

